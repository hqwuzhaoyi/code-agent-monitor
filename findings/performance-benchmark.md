# ReAct 提取器性能基准测试

## 测试环境

- 日期: 2026-02-25
- 模型: MiniMax/M2.5 (默认) 或 claude-haiku-4-5-20251001
- 超时配置: 5000ms (DEFAULT_TIMEOUT_MS)
- 最大 tokens: 1500 (DEFAULT_MAX_TOKENS)

## 迭代配置

默认 `IterationConfig`:
```rust
context_sizes: vec![80, 150, 300, 500, 800],
max_iterations: 5,
timeout_ms: 10000,
```

## 理论性能分析

### 1. 单次 API 调用开销

| 组件 | 估计耗时 |
|------|----------|
| 网络往返 (RTT) | 50-200ms |
| 模型推理 | 200-1000ms |
| 响应解析 | <10ms |
| **总计** | **250-1200ms** |

### 2. 各迭代级别的输入规模

| 迭代 | 行数 | 估计字符数 | 估计 tokens |
|------|------|------------|-------------|
| 1 | 80 | ~4,000 | ~1,000 |
| 2 | 150 | ~7,500 | ~1,875 |
| 3 | 300 | ~15,000 | ~3,750 |
| 4 | 500 | ~25,000 | ~6,250 |
| 5 | 800 | ~40,000 | ~10,000 |

*注: 假设平均每行 50 字符，每 4 字符约 1 token*

### 3. 最坏情况分析

如果每次迭代都返回 `NeedMoreContext`：

| 场景 | API 调用次数 | 总耗时估计 |
|------|--------------|------------|
| 最佳 (首次成功) | 1 | 250-1200ms |
| 中等 (3 次迭代) | 3 | 750-3600ms |
| 最坏 (5 次迭代) | 5 | 1250-6000ms |

### 4. Token 消耗估计

| 场景 | 输入 tokens | 输出 tokens | 总计 |
|------|-------------|-------------|------|
| 最佳 (80 行) | ~1,000 | ~200 | ~1,200 |
| 中等 (300 行) | ~3,750 | ~200 | ~3,950 |
| 最坏 (累计) | ~22,875 | ~1,000 | ~23,875 |

*注: 输出 tokens 基于 JSON 响应格式估计*

## 优化建议

### 1. 减少不必要的迭代

当前实现已优化：
- 一次性获取最大行数 (800 行) 的终端快照
- 从内存中截取不同行数，避免多次 tmux 调用

### 2. 提前终止条件

- `is_processing()` 检测：在 ReAct 循环前检测，避免无效 API 调用
- `Idle` 状态检测：首次迭代即可识别空闲状态

### 3. 缓存策略

可考虑的优化：
- 指纹缓存：相同 fingerprint 的消息不重复提取
- 状态缓存：短时间内相同终端内容不重复分析

### 4. 并行化

当前为串行迭代，可考虑：
- 并行发送多个上下文级别的请求
- 取最先返回的有效结果

## 实际测试结果

### 测试方法

```bash
# 启动测试 agent
cam start --agent mock

# 触发提取
cam watch-trigger --agent-id <id>
```

### 测试数据

*待补充实际测试数据*

| 测试场景 | 迭代次数 | 总耗时 | API 调用 |
|----------|----------|--------|----------|
| 简单问题 | - | - | - |
| 复杂问题 | - | - | - |
| 空闲状态 | - | - | - |
| 处理中 | - | - | - |

## 成本估算

基于 Anthropic Haiku 定价 (假设):
- 输入: $0.25 / 1M tokens
- 输出: $1.25 / 1M tokens

| 场景 | 输入成本 | 输出成本 | 总成本 |
|------|----------|----------|--------|
| 单次提取 (最佳) | $0.00025 | $0.00025 | $0.0005 |
| 单次提取 (最坏) | $0.0057 | $0.00125 | $0.007 |
| 每日 100 次提取 | $0.025-0.57 | $0.025-0.125 | $0.05-0.70 |

## 监控指标建议

### 关键指标

1. **提取成功率**: 成功提取 / 总尝试
2. **平均迭代次数**: 成功提取所需的平均迭代
3. **P50/P95/P99 延迟**: 提取耗时分布
4. **API 错误率**: API 调用失败比例

### 日志分析

现有日志已包含：
```rust
info!(
    session_id = %session_id,
    fingerprint = %message.fingerprint,
    iterations = iteration + 1,
    "Message extracted successfully"
);
```

可通过日志聚合分析实际性能。

## 结论

ReAct 提取器的性能主要受以下因素影响：

1. **网络延迟**: API 调用的主要开销
2. **上下文复杂度**: 决定需要多少迭代
3. **模型选择**: Haiku 比 Opus 快但可能需要更多迭代

建议：
- 生产环境使用 Haiku 模型
- 监控迭代次数分布，优化 context_sizes 配置
- 考虑添加缓存层减少重复提取
